/*d3-chart.js v1.0.0.2 Copyright 2021 m.k.  MIT License*/!function (t) { "use strict"; function i() { if (!arguments || 0 == arguments.length) return {}; for (var t = arguments[0] || {}, e = 1; e < arguments.length; e++)for (var o in arguments[e]) arguments[e].hasOwnProperty(o) && ("[object Object]" === Object.prototype.toString.call(arguments[e][o]) ? t[o] = i(t[o], arguments[e][o]) : t[o] = arguments[e][o]); return t } function e(t) { return void 0 === t || null == t } t || (t = "undefined" != typeof self && self ? self : window); var o = function (t) { const a = this; function r() { if (e(a.options.bindto.body)) { var t = a.options.bindto; a.options.bindto = { body: t } } e(a.options.bindto.x) && (a.options.bindto.x = a.options.bindto.body), e(a.options.bindto.x2) && (a.options.bindto.x2 = a.options.bindto.body), e(a.options.bindto.y) && (a.options.bindto.y = a.options.bindto.body), e(a.options.bindto.y2) && (a.options.bindto.y2 = a.options.bindto.body), a.options.data || (a.options.data = []); for (var o = 0; o < a.options.data.length; o++)a.options.data[o] = i({}, a.DataOptions, a.options.data[o]); window.removeEventListener("resize", v), a.options.autoResize && window.addEventListener("resize", v) } function s(t) { var i = (t = t || a.options).bindto.body, o = t.size.width, n = t.size.height, r = d3.select(i).node(); return e(o) && (o = r.clientWidth), e(n) && (n = r.clientHeight), t.size.margin && (0 == e(t.size.margin.x) && (o -= t.size.margin.x), 0 == e(t.size.margin.y) && (n -= t.size.margin.y)), { width: o, height: n } } function c(t, i) { return 0 == e(t) ? t : "function" == typeof i ? i() : i } function d(t, i, o, n) { return { min: c(t.min, function () { return function (i, o, n) { for (var a = void 0, r = 0; r < i.length; r++) { var s = i[r], c = 0 == n ? s.xScaleNo : s.yScaleNo; if (e(c) && (c = 1), c == o) { var d = s.values; if (0 != d.length) { var l = d[0], p = t.sorted || s.sorted && s.sorted[n] ? l[n] : d3.min(d, function (t) { return t[n] }); (void 0 === a || a > p) && (a = p) } } } return a }(i, o, n) }), max: c(t.max, function () { return function (i, o, n) { for (var a = void 0, r = 0; r < i.length; r++) { var s = i[r], c = 0 == n ? s.xScaleNo : s.yScaleNo; if (e(c) && (c = 1), c == o) { var d = Array.isArray(s) ? s : s.values; if (0 != d.length) { var l = d[d.length - 1], p = t.sorted || s.sorted && s.sorted[n] ? l[n] : d3.max(d, function (t) { return t[n] }); (void 0 === a || p > a) && (a = p) } } } return a }(i, o, n) }) } } function l(t, i, e) { var o = d3.select(t); return o.select("svg").remove(), o.append("svg").attr("width", i).attr("height", e).attr("style", "overflow:hidden;") } function p() { var t = a.options, i = t.bindto.body, o = t.padding, n = s(), r = n.width, c = n.height; a.containers = {}, a.width = r, a.height = c, a.containers.body = d3.select(i); var p = l(i, r, c); if (t.tooltip.show && !a.containers.tooltip && (a.containers.tooltip = d3.select("body").append("div").attr("class", "d3chart-tooltip")), i != t.bindto.x && 0 == e(t.bindto.x)) { var v = "top" == t.axis.x.position ? o.top : "bottom" == t.axis.x.position ? o.bottom : 0; l(t.bindto.x, r, v + 1) } if (i != t.bindto.x2 && 0 == e(t.bindto.x2)) { v = "top" == t.axis.x2.position ? o.top : "bottom" == t.axis.x2.position ? o.bottom : 0; l(t.bindto.x2, r, v + 1) } if (i != t.bindto.y && 0 == e(t.bindto.y)) { var f = "left" == t.axis.y.position ? o.left : "right" == t.axis.y.position ? o.right : 0; l(t.bindto.y, f + 1, c) } if (i != t.bindto.y2 && 0 == e(t.bindto.y2)) { f = "left" == t.axis.y2.position ? o.left : "right" == t.axis.y2.position ? o.right : 0; l(t.bindto.y2, f + 1, c) } var x = d(t.axis.x, t.data, 1, 0), y = d(t.axis.y, t.data, 1, 1), g = d(t.axis.x2, t.data, 2, 0), b = d(t.axis.y2, t.data, 2, 1); a.gridX = function (t, i) { var e = a.options.padding, o = a.containers.body.select("svg").append("g"); if (!t.show) return o; var n = Math.ceil(i.min / t.interval) * t.interval, r = (Math.floor(i.max / t.interval), t.interval, (a.width - e.left - e.right) / (i.max - i.min) * t.interval), s = d3.range(e.left + r, a.width - e.right + r, r), c = (n - i.min) / t.interval * r - r; return o.selectAll("line.d3chart-gridx-line").data(s).enter().append("line").attr("x1", function (t, i) { return t + c }).attr("y1", e.top).attr("x2", function (t, i) { return t + c }).attr("y2", a.height - e.bottom), o.selectAll("line").attr("stroke", "black").classed("d3chart-grid-line", !0).attr("shape-rendering", "crispEdges"), o.classed("d3chart-grid", !0).classed("d3chart-gridx", !0), o }(t.grid.x, x), a.gridY = function (t, i) { if (!t.show) return {}; var e = a.options.padding, o = a.containers.body.select("svg").append("g"); if (!t.show) return o; Math.ceil(i.min / t.interval), t.interval; var n = Math.floor(i.max / t.interval) * t.interval, r = (a.height - e.top - e.bottom) / (i.max - i.min) * t.interval, s = d3.range(a.height - e.bottom - r, e.top, -r), c = (i.max - n) / t.interval * r - 3; return o.selectAll("line.d3chart-gridy-line").data(s).enter().append("line").attr("y1", function (t, i) { return t + c }).attr("x1", e.left).attr("y2", function (t, i) { return t + c }).attr("x2", a.width - e.right), o.selectAll("line").attr("stroke", "black").classed("d3chart-grid-line", !0).attr("shape-rendering", "crispEdges"), o.classed("d3chart-grid", !0).classed("d3chart-gridy", !0), o }(t.grid.y, y), a.scaleX = d3.scaleLinear().domain([x.min, x.max]).range([o.left, r - o.right]), a.scaleY = d3.scaleLinear().domain([y.min, y.max]).range([c - o.bottom, o.top]), a.scaleX2 = d3.scaleLinear().domain([g.min, g.max]).range([o.left, r - o.right]), a.scaleY2 = d3.scaleLinear().domain([b.min, b.max]).range([c - o.bottom, o.top]), a.axisX = u(t.bindto.x, t.axis.x, [a.scaleX, a.scaleX2], "d3chart-axisx"), a.axisX2 = u(t.bindto.x2, t.axis.x2, [a.scaleX, a.scaleX2], "d3chart-axisx2"), a.axisY = u(t.bindto.y, t.axis.y, [a.scaleY, a.scaleY2], "d3chart-axisy"), a.axisY2 = u(t.bindto.y2, t.axis.y2, [a.scaleY, a.scaleY2], "d3chart-axisy2"), a.containers.charts = p.append("g"), a.containers.charts.classed("d3chart-chart", !0), a.containers.points = p.append("g"), a.containers.points.classed("d3chart-point", !0); for (var m = 0; m < t.data.length; m++) { var k = t.data[m], w = (k.type || a.options.type, h(k)); w && w.render() } if (t.point && t.point.show || t.tooltip && t.tooltip.show) { function O() { a.containers.tooltip.transition().duration(200).ease(d3.easeLinear).style("opacity", "0") } a.containers.body.on("mousemove", function (i) { for (var e = d3.mouse(this), o = "", n = 0; n < t.data.length; n++) { var r = t.data[n], s = h(r).mouseOver(n, r, e); s && (o += ("" == o ? "" : "<br />") + s) } "" == o ? O() : a.containers.tooltip.interrupt().style("visibility", "visible").style("opacity", "1").html(o).style("top", d3.event.pageY - 20 + "px").style("left", d3.event.pageX + 10 + "px") }).on("mouseout", function (i, e, o) { for (var n = 0; n < t.data.length; n++) { h(t.data[n]).mouseOut() } t.tooltip && t.tooltip.show && O() }) } } function h(t) { switch (t.type || a.options.type) { case "scale": return }return new n(a, t) } function u(t, i, o, n) { if (!i.show) return {}; const r = o[i.scaleNo - 1], s = r.domain()[0], c = r.domain()[1], d = a.options.padding, l = d3.select(t).select("svg").append("g"); var p, h = 0, u = 0, v = "", f = "", x = 1, y = 0; switch (i.direction || i.position) { case "top": p = d3.axisTop(r), v = "y1", f = "y2", x = -1; break; case "bottom": p = d3.axisBottom(r), v = "y2", f = "y1", x = 1; break; case "left": p = d3.axisLeft(r), v = "x1", f = "x2", x = -1; break; case "right": p = d3.axisRight(r), v = "x2", f = "x1", x = 1 }"top" == i.position ? d.top : "bottom" == i.position ? d.bottom : "left" == i.position ? d.left : "right" == i.position && d.right; switch (i.position) { case "top": u = d.top; break; case "bottom": u = a.height - d.bottom; break; case "left": h = d.left; break; case "right": h = a.width - d.right }var g = void 0, b = void 0, m = void 0; if (0 == e(i.values) && (g = i.values), i.tick && i.tick.interval) { g = []; for (var k = Math.ceil(s / i.tick.interval) * i.tick.interval, w = Math.floor(c / i.tick.interval) * i.tick.interval, O = i.tick.interval * (w > k ? 1 : -1), S = function (t) { return w > k ? t <= w : k <= t }, z = E(i.tick.interval), N = k; S(N); N += O) { var A = L(N, z); g.push(A) } } if (i.tick && i.tick.count && p.ticks(i.tick.count), i.tick && i.tick.scaleInterval) { k = Math.ceil(s / i.tick.scaleInterval) * i.tick.scaleInterval, w = Math.floor(c / i.tick.scaleInterval) * i.tick.scaleInterval, O = i.tick.scaleInterval * (w > k ? 1 : -1), S = function (t) { return w > k ? t <= w : k <= t }, z = E(i.tick.interval); m = [], b = (g || r.ticks()).slice(); for (N = k; S(N); N += O) { A = L(N, z); m.push(A), -1 == g.indexOf(A) && g.push(A) } } p.tickValues(g), p.tickFormat(function (t) { return m && -1 == m.indexOf(t) ? "" : i.tick && i.tick.format ? i.tick.format(t) : t }); var X = g || r.ticks(); for (N = 0; N < X.length; N++) { var Y = E(X[N]); Y > y && (y = Y) } l.classed("d3chart-axis", !0).classed(n, !0).attr("transform", "translate(" + h + "," + u + ")").call(p); const D = p.tickSize(); function M(t, o, n) { var a = L(t, y); if (b && -1 == b.indexOf(a)) return 0; if (e(i.tick)) return n; if (i.tick[o]) { if (m && -1 != m.indexOf(a) && i.tick.scaleSize) return i.tick.scaleSize; if ("number" == typeof i.tick[o]) return i.tick[o]; if ("function" == typeof i.tick[o]) return i.tick[o](a) } return n } function L(t, i) { var e = Math.pow(10, i); return Math.round(t * e) / e } function E(t) { var i = t.toString(), e = i.indexOf("."); return e <= 0 ? 0 : i.length - e - 1 } l.selectAll("g.tick line").attr(f, function (t) { return M(t, "innerSize", 0) }).attr(v, function (t) { return M(t, "size", D) * x }) } function v() { var t = s(); t.width == a.width && t.height == a.height || p() } !function (t) { a.options = i({}, o.DefaultOptions, t), r() }(t), p(), a.flush = p, a.update = function (t, e) { "object" == typeof a.options[t] && 0 == Array.isArray(a.options[t]) ? a.options[t] = i({}, a.options[t], e) : a.options[t] = e; r(), a.renderEnabled && p() }, a.beginUpdate = function () { a.renderEnabled = !1 }, a.endUpdate = function (t) { a.renderEnabled = !0, (t || e(t)) && (p(), a.needRender = !1) }, a.renderEnabled = !0 }, n = function (t, i) { const o = this; this.parent = t, this.options = t.options, this.data = i, this.render = function () { const t = o.options, i = o.parent, n = o.data, a = 2 == n.xScaleNo ? i.scaleX2 : i.scaleX, r = 2 == n.yScaleNo ? i.scaleY2 : i.scaleY; var s = i.containers.charts.append("path").datum(n.values).classed("d3chart-chart-line", !0).attr("stroke", "black").attr("d", d3.line().curve(function (t, i) { e(t) && (t = o.options.type); e(i) && (i = o.options.step); switch (t) { case "spline": return d3.curveCatmullRom; case "step": if (i) switch (i.type) { case "step-before": return d3.curveStepBefore; case "step-after": return d3.curveStepAfter }return d3.curveStep }return d3.curveLinear }(n.type, n.step)).x(function (t) { return a(t[0]) }).y(function (t) { return r(t[1]) })); if (n.color && s.attr("style", "stroke:" + n.color + ";"), n.className && s.classed(n.className, !0), t.point && t.point.show) { var c = i.containers.points.append("g").selectAll("circle").data(n.values).enter().append("circle").attr("cx", function (t) { return a(t[0]) }).attr("cy", function (t) { return r(t[1]) }).classed("d3chart-point-circle", !0); t.point && t.point.show ? c.attr("r", t.point.style.size) : c.attr("r", 4).classed("d3chart-point-circle-hidden", !0) } }, this.mouseOver = function (i, e, o) { for (var n = t.options, a = t.containers.points.nodes()[0].childNodes, r = e.values, s = 2 == e.xScaleNo ? t.scaleX2 : t.scaleX, c = 2 == e.yScaleNo ? t.scaleY2 : t.scaleY, d = n.point.style.size || 4, l = s.invert(o[0] - d), p = s.invert(o[0] + d), h = c.invert(o[1] - d), u = c.invert(o[1] + d), v = 0; v < r.length; v++) { var f = r[v], x = l <= f[0] && f[0] <= p || p <= f[0] && f[0] <= l, y = h <= f[1] && f[1] <= u || u <= f[1] && f[1] <= h; if (x) { var g = ""; if (n.tooltip.show && (n.tooltip.grouped || y) && (g = n.tooltip.format(f[0], f[1], e, v, n)), n.point.show && y) { var b = d3.select(a[i].childNodes[v]); b.classed("d3chart-point-circle-pointed", !0).attr("r", n.point.hoverStyle.size), n.point.hoverStyle.className && b.classed(n.point.hoverStyle.className, !0) } return g } } return "" }, this.mouseOut = function () { var i = t.options; if (i.point && i.point.show) { var e = d3.select(".d3chart-point-circle-pointed"); e.classed("d3chart-point-circle-pointed", !1).attr("r", i.point.style.size), i.point.hoverStyle.className && e.classed(i.point.hoverStyle.className, !1) } } }; t.D3Chart = o, t.D3Chart.DataOptions = { id: void 0, values: [], title: "", type: void 0, step: void 0, sorted: void 0, xScaleNo: 1, yScaleNo: 1, color: void 0, className: void 0 }, t.D3Chart.AxisOptions = { show: !0, min: void 0, max: void 0, sorted: !1, padding: void 0, label: void 0, tick: { interval: void 0, scaleInterval: void 0, count: void 0, format: void 0, size: 6, innerSize: 0, scaleSize: void 0 }, position: void 0, direction: void 0, scaleNo: 1 }, t.D3Chart.GridOptions = { show: !1, interval: void 0 }, t.D3Chart.PointOptions = { size: 4, className: void 0 }, t.D3Chart.DefaultOptions = { bindto: void 0, data: void 0, size: { width: void 0, height: void 0 }, type: "line", step: void 0, axis: { y: i({}, o.AxisOptions, { position: "left", scaleNo: 1 }), y2: i({}, o.AxisOptions, { show: !1, position: "right", scaleNo: 2 }), x: i({}, o.AxisOptions, { position: "bottom", scaleNo: 1 }), x2: i({}, o.AxisOptions, { show: !1, position: "top", scaleNo: 2 }) }, grid: { x: o.GridOptions, y: o.GridOptions }, padding: { top: 20, left: 40, bottom: 40, right: 20 }, tooltip: { show: !1, grouped: !0, format: function (t, i, e, o, n) { return "x:" + t + " y:" + i } }, point: { show: !1, style: i({}, o.PointOptions), hoverStyle: i({}, o.PointOptions, { size: 6 }) }, autoResize: !0 } }(this);