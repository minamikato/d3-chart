!function (t) { "use strict"; function i() { if (!arguments || 0 == arguments.length) return {}; for (var t = arguments[0] || {}, o = 1; o < arguments.length; o++)for (var e in arguments[o]) arguments[o].hasOwnProperty(e) && ("[object Object]" === Object.prototype.toString.call(arguments[o][e]) ? t[e] = i(t[e], arguments[o][e]) : t[e] = arguments[o][e]); return t } function o(t) { return void 0 === t || null == t } t || (t = "undefined" != typeof self && self ? self : window); var e = function (t) { const a = this; function r() { if (o(a.options.bindto.body)) { var t = a.options.bindto; a.options.bindto = { body: t } } o(a.options.bindto.x) && (a.options.bindto.x = a.options.bindto.body), o(a.options.bindto.x2) && (a.options.bindto.x2 = a.options.bindto.body), o(a.options.bindto.y) && (a.options.bindto.y = a.options.bindto.body), o(a.options.bindto.y2) && (a.options.bindto.y2 = a.options.bindto.body), a.options.data || (a.options.data = []); for (var e = 0; e < a.options.data.length; e++)a.options.data[e] = i({}, a.DataOptions, a.options.data[e]); window.removeEventListener("resize", u), a.options.autoResize && window.addEventListener("resize", u) } function s(t) { var i = (t = t || a.options).bindto.body, e = t.size.width, n = t.size.height, r = d3.select(i).node(); return o(e) && (e = r.clientWidth), o(n) && (n = r.clientHeight), t.size.margin && (0 == o(t.size.margin.x) && (e -= t.size.margin.x), 0 == o(t.size.margin.y) && (n -= t.size.margin.y)), { width: e, height: n } } function c(t, i) { return 0 == o(t) ? t : "function" == typeof i ? i() : i } function d(t, i, e, n) { return { min: c(t.min, function () { return function (i, e, n) { for (var a = void 0, r = 0; r < i.length; r++) { var s = i[r], c = 0 == n ? s.xScaleNo : s.yScaleNo; if (o(c) && (c = 1), c == e) { var d = s.values; if (0 != d.length) { var l = d[0], p = t.sorted || s.sorted && s.sorted[n] ? l[n] : d3.min(d, function (t) { return t[n] }); (void 0 === a || a > p) && (a = p) } } } return a }(i, e, n) }), max: c(t.max, function () { return function (i, e, n) { for (var a = void 0, r = 0; r < i.length; r++) { var s = i[r], c = 0 == n ? s.xScaleNo : s.yScaleNo; if (o(c) && (c = 1), c == e) { var d = Array.isArray(s) ? s : s.values; if (0 != d.length) { var l = d[d.length - 1], p = t.sorted || s.sorted && s.sorted[n] ? l[n] : d3.max(d, function (t) { return t[n] }); (void 0 === a || p > a) && (a = p) } } } return a }(i, e, n) }) } } function l(t, i, o) { var e = d3.select(t); return e.select("svg").remove(), e.append("svg").attr("width", i).attr("height", o).attr("style", "overflow:hidden;") } function p() { var t = a.options, i = t.bindto.body, e = t.padding, n = s(), r = n.width, c = n.height; a.containers = {}, a.width = r, a.height = c, a.containers.body = d3.select(i); var p = l(i, r, c); if (t.tooltip.show && !a.containers.tooltip && (a.containers.tooltip = d3.select("body").append("div").attr("class", "d3chart-tooltip")), i != t.bindto.x && 0 == o(t.bindto.x)) { var u = "top" == t.axis.x.position ? e.top : "bottom" == t.axis.x.position ? e.bottom : 0; l(t.bindto.x, r, u + 1) } if (i != t.bindto.x2 && 0 == o(t.bindto.x2)) { u = "top" == t.axis.x2.position ? e.top : "bottom" == t.axis.x2.position ? e.bottom : 0; l(t.bindto.x2, r, u + 1) } if (i != t.bindto.y && 0 == o(t.bindto.y)) { var f = "left" == t.axis.y.position ? e.left : "right" == t.axis.y.position ? e.right : 0; l(t.bindto.y, f + 1, c) } if (i != t.bindto.y2 && 0 == o(t.bindto.y2)) { f = "left" == t.axis.y2.position ? e.left : "right" == t.axis.y2.position ? e.right : 0; l(t.bindto.y2, f + 1, c) } var x = d(t.axis.x, t.data, 1, 0), y = d(t.axis.y, t.data, 1, 1), g = d(t.axis.x2, t.data, 2, 0), b = d(t.axis.y2, t.data, 2, 1); a.gridX = function (t, i) { var o = a.options.padding, e = a.containers.body.select("svg").append("g"); if (!t.show) return e; var n = Math.ceil(i.min / t.interval) * t.interval, r = (Math.floor(i.max / t.interval), t.interval, (a.width - o.left - o.right) / (i.max - i.min) * t.interval), s = d3.range(o.left + r, a.width - o.right + r, r), c = (n - i.min) / t.interval * r - r; return e.selectAll("line.d3chart-gridx-line").data(s).enter().append("line").attr("x1", function (t, i) { return t + c }).attr("y1", o.top).attr("x2", function (t, i) { return t + c }).attr("y2", a.height - o.bottom), e.selectAll("line").attr("stroke", "black").classed("d3chart-grid-line", !0).attr("shape-rendering", "crispEdges"), e.classed("d3chart-grid", !0).classed("d3chart-gridx", !0), e }(t.grid.x, x), a.gridY = function (t, i) { if (!t.show) return {}; var o = a.options.padding, e = a.containers.body.select("svg").append("g"); if (!t.show) return e; Math.ceil(i.min / t.interval), t.interval; var n = Math.floor(i.max / t.interval) * t.interval, r = (a.height - o.top - o.bottom) / (i.max - i.min) * t.interval, s = d3.range(a.height - o.bottom - r, o.top, -r), c = (i.max - n) / t.interval * r - 3; return e.selectAll("line.d3chart-gridy-line").data(s).enter().append("line").attr("y1", function (t, i) { return t + c }).attr("x1", o.left).attr("y2", function (t, i) { return t + c }).attr("x2", a.width - o.right), e.selectAll("line").attr("stroke", "black").classed("d3chart-grid-line", !0).attr("shape-rendering", "crispEdges"), e.classed("d3chart-grid", !0).classed("d3chart-gridy", !0), e }(t.grid.y, y), a.scaleX = d3.scaleLinear().domain([x.min, x.max]).range([e.left, r - e.right]), a.scaleY = d3.scaleLinear().domain([y.min, y.max]).range([c - e.bottom, e.top]), a.scaleX2 = d3.scaleLinear().domain([g.min, g.max]).range([e.left, r - e.right]), a.scaleY2 = d3.scaleLinear().domain([b.min, b.max]).range([c - e.bottom, e.top]), a.axisX = v(t.bindto.x, t.axis.x, [a.scaleX, a.scaleX2], "d3chart-axisx"), a.axisX2 = v(t.bindto.x2, t.axis.x2, [a.scaleX, a.scaleX2], "d3chart-axisx2"), a.axisY = v(t.bindto.y, t.axis.y, [a.scaleY, a.scaleY2], "d3chart-axisy"), a.axisY2 = v(t.bindto.y2, t.axis.y2, [a.scaleY, a.scaleY2], "d3chart-axisy2"), a.charts = p.append("g"), a.charts.classed("d3chart-chart", !0), a.points = p.append("g"), a.points.classed("d3chart-point", !0); for (var m = 0; m < t.data.length; m++) { var k = t.data[m], w = (k.type || a.options.type, h(k)); w && w.render() } } function h(t) { switch (t.type || a.options.type) { case "scale": return }return new n(a, t) } function v(t, i, e, n) { if (!i.show) return {}; const r = e[i.scaleNo - 1], s = r.domain()[0], c = r.domain()[1], d = a.options.padding, l = d3.select(t).select("svg").append("g"); var p, h = 0, v = 0, u = "", f = "", x = 1, y = 0; switch (i.direction || i.position) { case "top": p = d3.axisTop(r), u = "y1", f = "y2", x = -1; break; case "bottom": p = d3.axisBottom(r), u = "y2", f = "y1", x = 1; break; case "left": p = d3.axisLeft(r), u = "x1", f = "x2", x = -1; break; case "right": p = d3.axisRight(r), u = "x2", f = "x1", x = 1 }"top" == i.position ? d.top : "bottom" == i.position ? d.bottom : "left" == i.position ? d.left : "right" == i.position && d.right; switch (i.position) { case "top": v = d.top; break; case "bottom": v = a.height - d.bottom; break; case "left": h = d.left; break; case "right": h = a.width - d.right }var g = void 0, b = void 0, m = void 0; if (0 == o(i.values) && (g = i.values), i.tick && i.tick.interval) { g = []; for (var k = Math.ceil(s / i.tick.interval) * i.tick.interval, w = Math.floor(c / i.tick.interval) * i.tick.interval, S = i.tick.interval * (w > k ? 1 : -1), z = function (t) { return w > k ? t <= w : k <= t }, O = L(i.tick.interval), N = k; z(N); N += S) { var A = E(N, O); g.push(A) } } if (i.tick && i.tick.count && p.ticks(i.tick.count), i.tick && i.tick.scaleInterval) { k = Math.ceil(s / i.tick.scaleInterval) * i.tick.scaleInterval, w = Math.floor(c / i.tick.scaleInterval) * i.tick.scaleInterval, S = i.tick.scaleInterval * (w > k ? 1 : -1), z = function (t) { return w > k ? t <= w : k <= t }, O = L(i.tick.interval); m = [], b = (g || r.ticks()).slice(); for (N = k; z(N); N += S) { A = E(N, O); m.push(A), -1 == g.indexOf(A) && g.push(A) } } p.tickValues(g), p.tickFormat(function (t) { return m && -1 == m.indexOf(t) ? "" : i.tick && i.tick.format ? i.tick.format(t) : t }); var X = g || r.ticks(); for (N = 0; N < X.length; N++) { var Y = L(X[N]); Y > y && (y = Y) } l.classed("d3chart-axis", !0).classed(n, !0).attr("transform", "translate(" + h + "," + v + ")").call(p); const D = p.tickSize(); function M(t, e, n) { var a = E(t, y); if (b && -1 == b.indexOf(a)) return 0; if (o(i.tick)) return n; if (i.tick[e]) { if (m && -1 != m.indexOf(a) && i.tick.scaleSize) return i.tick.scaleSize; if ("number" == typeof i.tick[e]) return i.tick[e]; if ("function" == typeof i.tick[e]) return i.tick[e](a) } return n } function E(t, i) { var o = Math.pow(10, i); return Math.round(t * o) / o } function L(t) { var i = t.toString(), o = i.indexOf("."); return o <= 0 ? 0 : i.length - o - 1 } l.selectAll("g.tick line").attr(f, function (t) { return M(t, "innerSize", 0) }).attr(u, function (t) { return M(t, "size", D) * x }) } function u() { var t = s(); t.width == a.width && t.height == a.height || p() } !function (t) { a.options = i({}, e.DefaultOptions, t), r() }(t), p(), a.flush = p, a.update = function (t, o) { "object" == typeof a.options[t] && 0 == Array.isArray(a.options[t]) ? a.options[t] = i({}, a.options[t], o) : a.options[t] = o; r(), a.renderEnabled && p() }, a.beginUpdate = function () { a.renderEnabled = !1 }, a.endUpdate = function (t) { a.renderEnabled = !0, (t || o(t)) && (p(), a.needRender = !1) }, a.renderEnabled = !0 }, n = function (t, i) { const e = this; this.parent = t, this.options = t.options, this.data = i, this.render = function () { const t = e.options, i = e.parent, n = e.data, a = 2 == n.xScaleNo ? i.scaleX2 : i.scaleX, r = 2 == n.yScaleNo ? i.scaleY2 : i.scaleY; var s = i.charts.append("path").datum(n.values).classed("d3chart-chart-line", !0).attr("stroke", "black").attr("d", d3.line().curve(function (t, i) { o(t) && (t = e.options.type); o(i) && (i = e.options.step); switch (t) { case "spline": return d3.curveCatmullRom; case "step": if (i) switch (i.type) { case "step-before": return d3.curveStepBefore; case "step-after": return d3.curveStepAfter }return d3.curveStep }return d3.curveLinear }(n.type, n.step)).x(function (t) { return a(t[0]) }).y(function (t) { return r(t[1]) })); if (n.color && s.attr("style", "stroke:" + n.color + ";"), n.className && s.classed(n.className, !0), t.point && t.point.show || t.tooltip && t.tooltip.show) { var c = i.points.append("g").selectAll("circle").data(n.values).enter().append("circle").attr("cx", function (t) { return a(t[0]) }).attr("cy", function (t) { return r(t[1]) }).classed("d3chart-point-circle", !0).on("mouseover", function (o, e, a) { var r = d3.select(a[e]); if (t.point && t.point.show && (r.attr("r", t.point.hoverStyle.size), t.point.hoverStyle.className && r.classed(t.point.hoverStyle.className, !0)), t.tooltip && t.tooltip.show) { var s = t.tooltip.format(o[0], o[1], n, e, t); i.containers.tooltip.style("visibility", "visible").html(s) } }).on("mousemove", function (o, e, n) { t.tooltip && t.tooltip.show && i.containers.tooltip.style("top", d3.event.pageY - 20 + "px").style("left", d3.event.pageX + 10 + "px") }).on("mouseout", function (o, e, n) { var a = d3.select(n[e]); t.point && t.point.show && (a.attr("r", t.point.style.size), t.point.hoverStyle.className && a.classed(t.point.hoverStyle.className, !1)), t.tooltip && t.tooltip.show && i.containers.tooltip.style("visibility", "hidden") }); t.point && t.point.show ? c.attr("r", t.point.style.size) : c.attr("r", 4).classed("d3chart-point-circle-hidden", !0) } } }; t.D3Chart = e, t.D3Chart.DataOptions = { id: void 0, values: [], title: "", type: void 0, step: void 0, sorted: void 0, xScaleNo: 1, yScaleNo: 1, color: void 0, className: void 0 }, t.D3Chart.AxisOptions = { show: !0, min: void 0, max: void 0, sorted: !1, padding: void 0, label: void 0, tick: { interval: void 0, scaleInterval: void 0, count: void 0, format: void 0, size: 6, innerSize: 0, scaleSize: void 0 }, position: void 0, direction: void 0, scaleNo: 1 }, t.D3Chart.GridOptions = { show: !1, interval: void 0 }, t.D3Chart.PointOptions = { size: 4, className: void 0 }, t.D3Chart.DefaultOptions = { bindto: void 0, data: void 0, size: { width: void 0, height: void 0 }, type: "line", step: void 0, axis: { y: i({}, e.AxisOptions, { position: "left", scaleNo: 1 }), y2: i({}, e.AxisOptions, { show: !1, position: "right", scaleNo: 2 }), x: i({}, e.AxisOptions, { position: "bottom", scaleNo: 1 }), x2: i({}, e.AxisOptions, { show: !1, position: "top", scaleNo: 2 }) }, grid: { x: e.GridOptions, y: e.GridOptions }, padding: { top: 20, left: 40, bottom: 40, right: 20 }, tooltip: { show: !1, format: function (t, i, o, e, n) { return "x:" + t + " y:" + i } }, point: { show: !1, style: e.PointOptions, hoverStyle: e.PointOptions }, autoResize: !0 } }(this);