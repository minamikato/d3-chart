/*d3-chart.js v1.0.0 Copyright 2021 m.k.  MIT License*/!function (t) { "use strict"; function i() { if (!arguments || 0 == arguments.length) return {}; for (var t = arguments[0] || {}, e = 1; e < arguments.length; e++)for (var o in arguments[e]) arguments[e].hasOwnProperty(o) && ("[object Object]" === Object.prototype.toString.call(arguments[e][o]) ? t[o] = i(t[o], arguments[e][o]) : t[o] = arguments[e][o]); return t } function e(t) { return void 0 === t || null == t } t || (t = "undefined" != typeof self && self ? self : window); var o = function (t) { const r = this; function s() { if (e(r.options.bindto.body)) { var t = r.options.bindto; r.options.bindto = { body: t } } e(r.options.bindto.x) && (r.options.bindto.x = r.options.bindto.body), e(r.options.bindto.x2) && (r.options.bindto.x2 = r.options.bindto.body), e(r.options.bindto.y) && (r.options.bindto.y = r.options.bindto.body), e(r.options.bindto.y2) && (r.options.bindto.y2 = r.options.bindto.body), r.options.data || (r.options.data = []); for (var o = 0; o < r.options.data.length; o++)r.options.data[o] = i({}, r.DataOptions, r.options.data[o]); window.removeEventListener("resize", u), r.options.autoResize && window.addEventListener("resize", u) } function a(t) { var i = (t = t || r.options).bindto.body, o = t.size.width, n = t.size.height, s = d3.select(i).node(); return e(o) && (o = s.clientWidth), e(n) && (n = s.clientHeight), t.size.margin && (0 == e(t.size.margin.x) && (o -= t.size.margin.x), 0 == e(t.size.margin.y) && (n -= t.size.margin.y)), { width: o, height: n } } function c(t, i) { return 0 == e(t) ? t : "function" == typeof i ? i() : i } function d(t, i, e) { return { min: c(t.min, function () { return function (i, e) { for (var o = void 0, n = 0; n < i.length; n++) { var r = i[n], s = r.values; if (0 != s.length) { var a = s[0], c = t.sorted || r.sorted && r.sorted[e] ? a[e] : d3.min(s, function (t) { return t[e] }); (void 0 === o || o > c) && (o = c) } } return o }(i, e) }), max: c(t.max, function () { return function (i, e) { for (var o = void 0, n = 0; n < i.length; n++) { var r = i[n], s = Array.isArray(r) ? r : r.values; if (0 != s.length) { var a = s[s.length - 1], c = t.sorted || r.sorted && r.sorted[e] ? a[e] : d3.max(s, function (t) { return t[e] }); (void 0 === o || c > o) && (o = c) } } return o }(i, e) }) } } function l(t, i, e) { var o = d3.select(t); return o.select("svg").remove(), o.append("svg").attr("width", i).attr("height", e).attr("style", "overflow:hidden;") } function p() { var t = r.options, i = t.bindto.body, o = t.padding, n = a(), s = n.width, c = n.height; r.containers = {}, r.width = s, r.height = c, r.containers.body = d3.select(i); var p = l(i, s, c); if (t.tooltip.show && !r.containers.tooltip && (r.containers.tooltip = d3.select("body").append("div").attr("class", "d3chart-tooltip")), i != t.bindto.x && 0 == e(t.bindto.x)) { var u = "top" == t.axis.x.position ? o.top : "bottom" == t.axis.x.position ? o.bottom : 0; l(t.bindto.x, s, u + 1) } if (i != t.bindto.x2 && 0 == e(t.bindto.x2)) { u = "top" == t.axis.x2.position ? o.top : "bottom" == t.axis.x2.position ? o.bottom : 0; l(t.bindto.x2, s, u + 1) } if (i != t.bindto.y && 0 == e(t.bindto.y)) { var v = "left" == t.axis.y.position ? o.left : "right" == t.axis.y.position ? o.right : 0; l(t.bindto.y, v + 1, c) } if (i != t.bindto.y2 && 0 == e(t.bindto.y2)) { v = "left" == t.axis.y2.position ? o.left : "right" == t.axis.y2.position ? o.right : 0; l(t.bindto.y2, v + 1, c) } var x = d(t.axis.x, t.data, 0), y = d(t.axis.y, t.data, 1); r.gridX = function (t, i) { var e = r.options.padding, o = r.containers.body.select("svg").append("g"), n = (r.width - e.left - e.right) / (i.max - i.min) * t.step; if (t.show) { var s = d3.range(e.left + n, r.width - e.right + n, n); o.selectAll("line.d3chart-gridx-line").data(s).enter().append("line").attr("x1", function (t, i) { return t + 0 }).attr("y1", e.top).attr("x2", function (t, i) { return t + 0 }).attr("y2", r.height - e.bottom), o.selectAll("line").attr("stroke", "black").classed("d3chart-grid-line", !0).attr("shape-rendering", "crispEdges"), o.classed("d3chart-grid", !0).classed("d3chart-gridx", !0) } return o }(t.grid.x, x), r.gridY = function (t, i) { if (!t.show) return {}; var e = r.options.padding, o = r.containers.body.select("svg").append("g"), n = (r.height - e.top - e.bottom) / (i.max - i.min) * t.step; if (t.show) { var s = d3.range(r.height - e.bottom - n, e.top, -n), a = n - e.top % n - 3; o.selectAll("line.d3chart-gridy-line").data(s).enter().append("line").attr("x1", e.left).attr("y1", function (t, i) { return t + a }).attr("x2", r.width - e.right).attr("y2", function (t, i) { return t + a }), o.selectAll("line").attr("stroke", "black").classed("d3chart-grid-line", !0).attr("shape-rendering", "crispEdges"), o.classed("d3chart-grid", !0).classed("d3chart-gridy", !0) } return o }(t.grid.y, y), r.scaleX = d3.scaleLinear().domain([x.min, x.max]).range([o.left, s - o.right]), r.scaleY = d3.scaleLinear().domain([y.min, y.max]).range([c - o.bottom, o.top]), r.axisX = f(t.bindto.x, t.axis.x, r.scaleX, x, "d3chart-axisx"), r.axisX2 = f(t.bindto.x2, t.axis.x2, r.scaleX, x, "d3chart-axisx2"), r.axisY = f(t.bindto.y, t.axis.y, r.scaleY, y, "d3chart-axisy"), r.axisY2 = f(t.bindto.y2, t.axis.y2, r.scaleY, y, "d3chart-axisy2"), r.charts = p.append("g"), r.charts.classed("d3chart-chart", !0), r.points = p.append("g"), r.points.classed("d3chart-point", !0); for (var b = 0; b < t.data.length; b++) { var g = t.data[b], m = (g.type || r.options.type, h(g)); m && m.render() } } function h(t) { switch (t.type || r.options.type) { case "scale": return }return new n(r, t) } function f(t, i, o, n, s) { if (!i.show) return {}; const a = r.options.padding, c = d3.select(t).select("svg").append("g"); var d, l = 0, p = 0, h = "", f = "", u = 1; switch (i.direction || i.position) { case "top": d = d3.axisTop(o), h = "y1", f = "y2", u = -1; break; case "bottom": d = d3.axisBottom(o), h = "y2", f = "y1", u = 1; break; case "left": d = d3.axisLeft(o), h = "x1", f = "x2", u = -1; break; case "right": d = d3.axisRight(o), h = "x2", f = "x1", u = 1 }"top" == i.position ? a.top : "bottom" == i.position ? a.bottom : "left" == i.position ? a.left : "right" == i.position && a.right; switch (i.position) { case "top": p = a.top; break; case "bottom": p = r.height - a.bottom; break; case "left": l = a.left; break; case "right": l = r.width - a.right }var v = i.values, x = void 0, y = void 0; if (i.tick && (i.tick.interval || i.tick.scaleInterval)) { if (v = [], x = [], y = [], e(i.tick.scaleInterval) && (i.tick.scaleInterval = i.tick), e(i.tick) && (i.tick = i.tick.scaleInterval), 0 == e(i.tick.scaleInterval)) { var b = Math.ceil(n.min / i.tick.scaleInterval) * i.tick.scaleInterval; if ((m = Math.floor(n.max / i.tick.scaleInterval) * i.tick.scaleInterval) > b) for (var g = b; g <= m; g += i.tick.scaleInterval)v.push(g), x.push(g); else for (g = b; g >= m; g -= i.tick.scaleInterval)v.push(g), x.push(g) } if (0 == e(i.tick.interval)) { var m; b = Math.ceil(n.min / i.tick.interval) * i.tick.interval; if ((m = Math.floor(n.max / i.tick.interval) * i.tick.interval) > b) for (g = b; g <= m; g += i.tick.interval)y.push(g), -1 == v.indexOf(g) && v.push(g); else for (g = b; g >= m; g -= i.tick.interval)y.push(g), -1 == v.indexOf(g) && v.push(g) } v = v.sort(function (t, i) { return t - i }) } else if (i.tick && i.tick.count) { v = [], x = [], y = []; var k = Math.ceil((n.max - n.min) / i.tick.count); if (n.max >= n.min) for (g = n.min; g <= n.max; g += k)y.push(g), v.push(g), x.push(g); else for (g = n.min; g >= n.max; g -= k)y.push(g), v.push(g), x.push(g) } 0 == e(v) ? d.tickValues(v).tickFormat(function (t) { return x && -1 == x.indexOf(t) ? "" : i.tick && i.tick.format ? i.tick.format(t) : t }) : d.tickFormat(i.tick.format), c.classed("d3chart-axis", !0).classed(s, !0).attr("transform", "translate(" + l + "," + p + ")").call(d); const w = d.tickSize(); c.selectAll("g.tick line").attr(f, function (t) { if (y && -1 == y.indexOf(t)) return 0; if (e(i.tick)) return 0; if (i.tick.innerSize) { if (x && -1 != x.indexOf(t) && i.tick.scaleSize) return i.tick.scaleSize; if ("number" == typeof i.tick.innerSize) return i.tick.innerSize; if ("function" == typeof i.tick.innerSize) return i.tick.innerSize(t) } return 0 }).attr(h, function (t) { return function () { if (y && -1 == y.indexOf(t)) return 0; if (e(i.tick)) return w; if (x && -1 != x.indexOf(t) && i.tick.scaleSize) return i.tick.scaleSize; if (i.tick.size) { if ("number" == typeof i.tick.size) return i.tick.size; if ("function" == typeof i.tick.size) return i.tick.size(t) } return w }() * u }) } function u() { var t = a(); t.width == r.width && t.height == r.height || p() } !function (t) { r.options = i({}, o.DefaultOptions, t), s() }(t), p(), r.flush = p, r.update = function (t, e) { "object" == typeof r.options[t] && 0 == Array.isArray(r.options[t]) ? r.options[t] = i({}, r.options[t], e) : r.options[t] = e; s(), r.renderEnabled && p() }, r.beginUpdate = function () { r.renderEnabled = !1 }, r.endUpdate = function (t) { r.renderEnabled = !0, (t || e(t)) && (p(), r.needRender = !1) }, r.renderEnabled = !0 }, n = function (t, i) { const o = this; this.parent = t, this.options = t.options, this.data = i, this.render = function () { const t = o.options, i = o.parent, n = o.data; i.charts.append("path").datum(n.values).classed("d3chart-chart-line", !0).attr("stroke", "black").attr("d", d3.line().curve(function (t, i) { e(t) && (t = o.options.type); e(i) && (i = o.options.step); switch (t) { case "spline": return d3.curveCatmullRom; case "step": if (i) switch (i.type) { case "step-before": return d3.curveStepBefore; case "step-after": return d3.curveStepAfter }return d3.curveStep }return d3.curveLinear }(n.type, n.step)).x(function (t) { return i.scaleX(t[0]) }).y(function (t) { return i.scaleY(t[1]) })); if (t.point && t.point.show || t.tooltip && t.tooltip.show) { var r = i.points.append("g").selectAll("circle").data(n.values).enter().append("circle").attr("cx", function (t) { return i.scaleX(t[0]) }).attr("cy", function (t) { return i.scaleY(t[1]) }).classed("d3chart-point-circle", !0).on("mouseover", function (e, o, n) { var r = d3.select(n[o]); if (t.point && t.point.show && (r.attr("r", t.point.hoverStyle.size), t.point.hoverStyle.className && r.classed(t.point.hoverStyle.className, !0)), t.tooltip && t.tooltip.show) { var s = t.tooltip.format(e[0], e[1], o, t); i.containers.tooltip.style("visibility", "visible").html(s) } }).on("mousemove", function (e, o, n) { t.tooltip && t.tooltip.show && i.containers.tooltip.style("top", d3.event.pageY - 20 + "px").style("left", d3.event.pageX + 10 + "px") }).on("mouseout", function (e, o, n) { var r = d3.select(n[o]); t.point && t.point.show && (r.attr("r", t.point.style.size), t.point.hoverStyle.className && r.classed(t.point.hoverStyle.className, !1)), t.tooltip && t.tooltip.show && i.containers.tooltip.style("visibility", "hidden") }); t.point && t.point.show ? r.attr("r", t.point.style.size) : r.attr("r", 4).classed("d3chart-point-circle-hidden", !0) } } }; t.D3Chart = o, t.D3Chart.DataOptions = { id: void 0, values: [], title: "", type: void 0, step: void 0, sorted: void 0, xScaleNo: 1, yScaleNo: 1 }, t.D3Chart.AxisOptions = { show: !0, min: void 0, max: void 0, sorted: !1, padding: void 0, label: void 0, tick: { interval: void 0, scaleInterval: void 0, count: void 0, format: void 0, size: 6, innerSize: 0, scaleSize: void 0 }, position: void 0, direction: void 0 }, t.D3Chart.GridOptions = { show: !1, step: void 0 }, t.D3Chart.PointOptions = { size: 4, className: void 0 }, t.D3Chart.DefaultOptions = { bindto: void 0, data: void 0, size: { width: void 0, height: void 0 }, type: "line", step: void 0, axis: { y: i({}, o.AxisOptions, { position: "left" }), y2: i({}, o.AxisOptions, { show: !1, position: "right" }), x: i({}, o.AxisOptions, { position: "bottom" }), x2: i({}, o.AxisOptions, { show: !1, position: "top" }) }, grid: { x: o.GridOptions, y: o.GridOptions }, padding: { top: 20, left: 40, bottom: 40, right: 20 }, tooltip: { show: !1, format: function (t, i, e, o) { return "x:" + t + " y:" + i } }, point: { show: !1, style: o.PointOptions, hoverStyle: o.PointOptions }, autoResize: !0 } }(this);